<!-- <import name="card" src="../../assets/uxs/card/card.ux"></import> -->
<import name="cards" src="../../assets/uxs/card/cards.ux"></import>
<import name="btn" src="../../assets/uxs/button/HexagonalButton.ux"></import>
<import name="enemy" src="../../assets/uxs/enemy/enemy.ux"></import>
<import name="hpbar" src="../../assets/uxs/others/HpBar.ux"></import>
<import name="card" src="../../assets/uxs/card/card.ux"></import>
<import name="player" src="../../assets/uxs/player/player.ux"></import>
<import name="cardLayer" src="../../assets/uxs/CardCoverLayer/CardCoverLayer.ux"></import>
 
   
 
 
<template>
  <div class="wrapper">
    <player prop-player={{Player}} class="playerblock"></player>
    <image src="../../assets/images/button/base1.png" id="drawPile" onclick="drawPileShow"></image>
    <image src="../../assets/images/button/base2.png" id="dicordPile" onclick="dicordPileShow"></image>
    <!--text>123</text-->
    <div class="EnergyBadge">
      <text class="energy">{{ NowEnergy }}/{{ MaxEnergy }}</text>
    </div>
    <div class="Enemies" style="position: absolute; top: 400px">
      <enemy
        for="value in enemiesProps"
        width="200"
        height="200"
        prop-enemy="{{value}}"
        onenemy-select="handleSelectingEnemy"
        prop-select-enemy="{{SelectEnemy}}"
      ></enemy>
    </div>

    <cards
      class="cardsHand"
      card-paras="{{cards}}"
      oncard-clickd="handleCardClicked"
      oncards-seleting="handlecardSelecting"
      prop-sended="sending"
    ></cards>
    <btn
      class="sendCardBtn"
      prop-text="出牌"
      prop-style="{{btn1Style}}"
      onclick="sendBtnClicked"
    ></btn>
    <btn
      class="endTurnBtn"
      prop-text="结束回合"
      prop-style="{{btn1Style}}"
      onclick="test"
    ></btn>
    <!-- <image class="btn" src="../../assets/images/button/buttonL.png"></image> -->
    <cardLayer if="{{drawPileShowing}}" prop-cards="{{drawCards}}"  onclick="closeDrawPileShow">

    </cardLayer>
    <cardLayer  if="{{dicordPileShowing}}" prop-cards="{{discordCards}}" onclick="closeDicordPileShow">
    </cardLayer>
  </div>
</template>
<script>
import global from "../../helper/global.js";
import fetch from '@system.fetch' 
import router from '@system.router'
export default {
  data() {
    return {
      initParams:null,
      drawPileShowing:false,
      dicordPileShowing:false,
      testvar:false,
      SelectEnemy: null,
      Player: {
        MaxHp: 100,
        NowHp: 100,
        NowBlock:40
      },
      enemiesProps: //[{id,monsterid,MaxHp,NowHp,NowBlock}]
      [],

      MaxEnergy: 3,
      NowEnergy: 3,
      selected: null,
      sending: null,
      btn1Style: {
        height: 81,
        width: 234,
        fontSize: 36
      },
      cardIdMapAttribute:{},//cardid 对应属性（对象）,cards里边只存储，一些描述id:{"cardid","title","description","cost"}
      cards:[], //[{id,cardid,width,cardName,cardCost,cardDc}]
      drawCards:[],
      discordCards:[],
    };
  },
  onInit() {
    //console.log(this.initParams)
    this.initParams = JSON.parse(this.initParams)
    //[{id,monsterid,MaxHp,NowHp,NowBlock,name,description}]
    let i = 0;
    let that = this;
    this.Player = {
        MaxHp:  this.initParams["battle_player"].maxhp,
        NowHp: this.initParams["battle_player"].nowhp,
        NowBlock:this.initParams["battle_player"].block
    };
    let intentObjs = this.initParams["intents"];
    this.initParams["monsters"].forEach(element => {
        let e1 = element;
        
        intentObjs.forEach(e2=>{
          //console.log(e1,e2)
          if(e1.monsterid==e2.monsterid)
          that.enemiesProps.push({
            id:i,
            monsterid:e1.monsterid,
            MaxHp:e1.maxhp,
            NowHp:e1.nowhp,
            NowBlock:e1.block,
            name:e1.name,
            description:e1.description,
            intent:that.intentParse(e2)
          })
        })
      i+=1;
    });
    //console.log(that.enemiesProps)
    fetch.fetch({
      url:this.$app.$def.url+":20002/battle/getCardsByIdMap",
      method:"POST",
      header:{
        "Content-Type":"application/json"
      },
      data:{
        "cardidsmap":this.initParams["battle_player"]["all_pile"]
      },
    }).then(Response=>{
      
      //console.log(Response)
      var data = JSON.parse(Response.data.data)
      var cardsObjs = data.data;
      cardsObjs.forEach(el=>{
        that.cardIdMapAttribute[el.cardid] = el;
      })

      var handPile = JSON.parse(this.initParams["battle_player"]["hand_pile"])["Array"]
      var drawPile = JSON.parse(this.initParams["battle_player"]["draw_pile"])["Array"]
      var discordPile = JSON.parse(this.initParams["battle_player"]["discord_pile"])["Array"]
      var j =0;
      handPile.forEach(element=>{
        var cardobj = that.cardIdMapAttribute[element];
        that.cards.push({
            id:j,
            cardid:cardobj.cardid,
            width:150,
            cardName:cardobj.title,
            cardCost:cardobj.cost,
            cardDc:cardobj.description
        })
        j+=1;
      })

      drawPile.forEach(element=>{
        var cardobj = that.cardIdMapAttribute[element];
        that.drawCards.push({
            id:j,
            cardid:cardobj.cardid,
            width:150,
            cardName:cardobj.title,
            cardCost:cardobj.cost,
            cardDc:cardobj.description
        })
        j+=1;
      })
      //console.log(that.drawCards)
      discordPile.forEach(element=>{
        var cardobj = that.cardIdMapAttribute[element];
        that.discordCards.push({
            id:j,
            cardid:cardobj.cardid,
            width:150,
            cardName:cardobj.title,
            cardCost:cardobj.cost,
            cardDc:cardobj.description
        })
        j+=1;
      })
    //console.log(that.discordCards)
      
    }).catch(Error=>{
      console.error(Error)
    })
    
    //this.initParams[""];


  },
  handlecardSelecting(e) {
    this.selected = e.detail.id;

  },
  sendCards(id) {



    this.sendCardsById(id);
  },
  sendCardsById(id) {
    this.cards = this.del(this.cards, id)
  },
  del(arr, id) {
    let sid = id;
    arr = arr.filter(element => element.id != sid);
    console.log(arr)
    return arr;
  },
  sendBtnClicked() {
    console.log("clicked")
    if (this.selected != null) {

      this.sendCards(this.selected)
      this.sending = true;
      //console.log(this.sending)
      this.sending = null;
    }
  },
  handleSelectingEnemy(e) {
    this.SelectEnemy = e.detail.id;
  },
  test() {
    //this.NowHp -= 10;
    // this.testvar=true;

    this.enemiesProps[0].NowHp-=10
  },
  drawPileShow(){
    this.drawPileShowing=true;
  },
  dicordPileShow(){
    this.dicordPileShowing=true;
  },
  closeDrawPileShow(){
    this.drawPileShowing=false;
  },
  closeDicordPileShow(){
    this.dicordPileShowing=false;
  },
  intentParse(aIntent){
    var ret = {
      attack:false,
      defend:false,
      skill:false,
      text:0,

    }
    if(aIntent.aim==="ATTACK")
    {

      ret.attack=true;
      if(aIntent.attack_amount==1){
        ret.text = aIntent.attack;

      }else{
        ret.text = aIntent.attack_amount+ "×"+  aIntent.attack ;
      }
      
    }else if(aIntent.aim==="DEFEND"){
      ret.defend=true;
      ret.text = aIntent.defend;
    }else{

    }
    return ret;
  }
}
</script>
<style>
.wrapper {
  position: relative;
  background-image: url('../../assets/images/battlescence/BattleScence1.jpg');
}
.playerblock{
  position: absolute;
  top:900px;
  left: 30px;
}
.Enemies {
  width: 750px;
  display: flex;

  flex-direction: row;
  justify-content: space-around;
}

.cardsHand {
  position: absolute;
  bottom: 0px;
  left: 0px;
}
.endTurnBtn {
  position: absolute;
  bottom: 300px;
  left: -234px;
}
.sendCardBtn {
  position: absolute;
  right: 0px;
  bottom: 300px;
}

.EnergyBadge {
  position: fixed;
  border: 3px solid rgba(0, 0, 0, 0.8);
  right: 30px;
  bottom: 500px;
  background-color: #116f54;
  height: 100px;
  width: 100px;
  transform: rotate(45deg);
}
.energy {
  width: 100px;
  text-align: center;
  font-size: 40px;
  transform: rotate(-45deg);
}
#drawPile{
  position: absolute;
  top: 100px;
  left:0px;
}
#dicordPile{
  position: absolute;
  top: 100px;
  right: 0px;
}
#drawcoverLayer{
  position: fixed;
  height: 100%;
  width: 100%;
  background-color:rgba(0, 0, 0,0.7);
  display: flex;
  flex-direction: row;
  justify-content: space-around;
  flex-wrap: wrap;
  align-items: flex-start;
  align-content: space-around;
}
#dicordcoverLayer{
  position: fixed;
  height: 100%;
  width: 100%;
  background-color:rgba(0, 0, 0,0.7);
  display: flex;
  flex-direction: row;
  justify-content: space-around;
  flex-wrap: wrap;
  align-items: flex-start;
  align-content: space-around;
}
</style>